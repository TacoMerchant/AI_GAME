<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>nodeID = noone;
radius = global.NodeRadius;
connectedNodes = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with(objNode) {
    if (id == other.id) {
        continue;
    }
    
    var index;
    index = ds_list_find_index(connectedNodes, other.id);
        if (index != -1) {
            ds_list_delete(connectedNodes, index);
        }
}


with(objGraph) {
    deleteNode(other.nodeID);
}
ds_list_destroy(connectedNodes);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var over;
over = (mouse_x &gt; x - radius &amp;&amp; mouse_y &gt; y - radius &amp;&amp; mouse_x &lt; x + radius &amp;&amp; mouse_y &lt; y + radius);

if (mouse_check_button_pressed(mb_left) &amp;&amp; over &amp;&amp; global.NodeDragging == noone) {
    global.NodeDragging = nodeID;
}

if (mouse_check_button_pressed(mb_right) &amp;&amp; over &amp;&amp; global.NodeDragging != nodeID) {
    instance_destroy();
}


if (keyboard_check_pressed(vk_space) &amp;&amp; over == true &amp;&amp; global.PathLineFromNode == noone) {
    global.LineFromNode = nodeID;
}

if (keyboard_check_pressed(vk_shift) &amp;&amp; over == true &amp;&amp; global.LineFromNode == noone) {
    global.PathLineFromNode = nodeID;
}


if (keyboard_check_released(vk_space) &amp;&amp; global.LineFromNode!=noone &amp;&amp; global.LineFromNode != nodeID &amp;&amp; over) {
var ins;
    with(objNode) {
        if (nodeID == global.LineFromNode) {
            ins = id;
            break;
        } 
    }
    
    var connected;
    connected = false;
    if (ds_list_find_index(ins.connectedNodes, id) != -1) {
        connected = true;
    } else if (ds_list_find_index(connectedNodes, ins) != -1) {
        connected = true;
    }
    
    if (!connected) {
        ds_list_add(ins.connectedNodes, id);
        with(objGraph) {
            connectNodes(global.LineFromNode, other.nodeID, getDistance(ins, other.id));
        }
    }
}

if (keyboard_check_released(vk_shift) &amp;&amp; global.PathLineFromNode!=noone &amp;&amp; global.PathLineFromNode != nodeID &amp;&amp; over) {
    if (global.ShortestPath != noone) {
        ds_list_destroy(global.ShortestPath);
    }
    
    with(objGraph) {
        global.ShortestPath = getShortestPath(global.PathLineFromNode, other.nodeID);
    }
    
    if (global.ShortestPath == noone) {
        show_message("Unable to find path.");
        global.PathLineFromNode = noone;
    } else {
        var i;
        global.Path = "Path: ";
        for (i = 0; i &lt; ds_list_size(global.ShortestPath); i+=1) {
            global.Path+=string(ds_list_find_value(global.ShortestPath, i)) + ",";
        }
        global.Path = string_copy(global.Path, 0, string_length(global.Path) - 1);
    }
}


if (global.NodeDragging == nodeID) {
    x = mouse_x;
    y = mouse_y;
    
    var ins, i, Other, Connections, endOfIteration, lastConnection, Neighbour;
    //Update distances of connections
    with(objNode) {
        for (i = 0; i &lt; ds_list_size(connectedNodes); i+=1) {
            ins = ds_list_find_value(connectedNodes, i);
            if (ins == other.id || id == other.id) {
                with(objGraph) {
                    connectNodes(other.nodeID, ins.nodeID, getDistance(other.id, ins));
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var over;
over = (mouse_x &gt; x - radius &amp;&amp; mouse_y &gt; y - radius &amp;&amp; mouse_x &lt; x + radius &amp;&amp; mouse_y &lt; y + radius);

draw_set_color(c_black);
draw_text(x - round(string_width(string(nodeID))/2), y - round(string_height(string(nodeID))/2), string(nodeID));

if (global.LineFromNode == nodeID || (global.LineFromNode != noone &amp;&amp; over)) {
    draw_set_color(c_green);
} else if (global.PathLineFromNode == nodeID || (global.PathLineFromNode != noone &amp;&amp; over)) {
    draw_set_color(c_yellow);
}

draw_circle(x, y, radius, true);

if (global.LineFromNode == nodeID || global.PathLineFromNode == nodeID) {
    var dir, X, Y;
    X = mouse_x; Y = mouse_y;
    with(objNode) {
        if (id == other.id) {
            continue;
        }
        over = (mouse_x &gt; x - radius &amp;&amp; mouse_y &gt; y - radius &amp;&amp; mouse_x &lt; x + radius &amp;&amp; mouse_y &lt; y + radius);
        if (over) {
            dir = point_direction(x, y, other.x, other.y);
            X = x + lengthdir_x(radius, dir);
            Y = y + lengthdir_y(radius, dir);
            break;
        }
    }
    
    dir = point_direction(x, y, X, Y);
    draw_line(x + lengthdir_x(radius, dir), y + lengthdir_y(radius, dir), X, Y);
}
draw_set_color(c_black);


var i;
for( i = 0; i &lt; ds_list_size(connectedNodes); i+=1) {
    var ins, dir;
    ins = ds_list_find_value(connectedNodes, i);
    dir = point_direction(x, y, ins.x, ins.y);
    
    draw_text(x - round((x - ins.x) / 2), y - round((y - ins.y)/2), string(getDistance(id, ins)));
    
    if (global.ShortestPath!=noone) {
        var ind;
        ind = ds_list_find_index(global.ShortestPath, nodeID);
        if (ind != -1) {
            if ( (ins.nodeID == ds_list_find_value(global.ShortestPath, ind + 1) &amp;&amp; ind + 1 &lt; ds_list_size(global.ShortestPath))
                || (ins.nodeID == ds_list_find_value(global.ShortestPath, ind - 1 ) &amp;&amp; ind - 1 &gt;= 0)) {
                draw_set_color(c_red);
            }
        }
    }
    draw_line(x + lengthdir_x(radius, dir), y + lengthdir_y(radius, dir), ins.x - lengthdir_x(ins.radius, dir), ins.y - lengthdir_y(ins.radius, dir));
    draw_set_color(c_black);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
